# kafka核心技术与实战
Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。
## kafka入门
### kafka是消息引擎系统
Apache Kafka 是一款开源的**消息引擎系统**。在国外有一个专门的名字叫 Messaging System，而在国内的书籍很多作者翻译成为“消息系统”。这是在片面强调消息主题的作用，而忽视了kafka该有的消息传递属性，kafka消息传递就像引擎一样，为生产端和消费端源源不断地传递着消息。
```

            ----------      produce    -------    consume     ----------
           | System A |   ----------> | kafka | -----------> | System B |
            ----------                 -------                ----------
            
```
#### 消息引擎传输的对象是消息
思考一个问题：既然消息引擎(kafka)是用来在不同系统之间进行消息传递的，那么如何设计这个消息格式才能保证在不同系统之间传递的可重用性和通用性？

| 厂商       | 序列化框架           |
|----------|-----------------|
| Google   | Protocol Buffer |
| Facebook | Thrift          |
| kafka    | 二进制的字节序列（byte）  |
#### 消息引擎传递消息的方式
如何传输消息属于消息引擎设计机制的一部分
##### 点对点模型
日常生活打电话就属于这种模型：A呼B的号码，只有B能接收到电话请求，其他人接收不到A的电话请求。
```

            ----------      produce    -------    consume     ----------
           | System A |   ----------> | kafka | -----------> | System B |
            ----------                 -------                ----------
            
```
##### 发布/订阅模型
它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。

**日常案例**：一个或者多个报社向天涯报刊(topic)发布报纸，报刊会根据订阅本报刊的人群推送报纸。
```


            -------------                                                            --------------
           | Publisher 1 |----                   -----------              --------->| Subscriber 1 |
            -------------     |                 |   kafka   |            |           --------------
                              |    produce      |  -------  |   consume  |       
              .........   ----|---------------> | | topic | | -----------|--------->   ..........
                              |                 |  -------  |            |
            -------------     |                  -----------             |           --------------
           | Publisher N |----                                            --------->| Subscriber N |
            -------------                                                            --------------
            
```
#### 消息引擎的作用
为什么系统 A 不能直接发送消息给系统 B，中间还要隔一个消息引擎呢？

**答案**：削峰填谷，所谓的“削峰填谷”就是指缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统，如果没有消息引擎的保护，“脆弱”的下游系统可能会直接被压垮导致全链路服务“雪崩”。

### kafka术语
#### broker
kafka 的服务端运行时会产生一个 broker 服务进程，故一个 kafka 集群是由多个 broker 组成，broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。一台服务器可以运行多个 broker 进程，但是为了 kafka 集群的高可用性，常见的做法是把 broker 分散运行在不同的机器上。
#### topic
topic 是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。比如支付类消息和订单类消息分别使用不同的 topic 来区分各自的业务类型。
#### partition
- 每个 topic 会划分一个或多个 partition，它是一组有序的消息日志，可以理解为是存储**消息** 的队列
- 生产者发布的**消息**只能存储到 topic 中某个 partition，类似抢锁机制
- **消息**在中 partition 的编号（offset）是从 0 开始
#### offset
偏移量，即**消息**在 partition 中的位置编号，offset 在 partition 中的编号一旦确定就不会发生改变。后面尽量的消息都是以追加的方式写入 partition，故 offset 是单调递增的。
#### replica
副本（replica），kafka 为了保证高可用性，提供两个策略：一个是集群部署时 broker 运行在不同的机器上；一个是 partition 的副本维护。即每个 partition 都会有一个或多个副本，其中只能有 1 个领导副本（leader replica）和 N-1 个追随副本（follower replica）。每个 partition 的多个副本会分别散落在不同的 broker 上。

- 领导副本：负责 partition 对**消息**的读写操作，当领导副本损坏，可通过选举机制从追随副本选出新的领导副本
- 追随副本：负责从领导副本那边同步**消息**数据（会存在一定的时间延时）

**问题思考**：为什么 kafka 副本策略不设计成和 MySQL 主从机制（主副本负责写，从副本负责读）一样的策略呢？

**答案**：Kafka副本不对外提供服务的意义: 如果允许follower副本对外提供读服务（主写从读），首先会存在数据一致性的问题，消息从主节点同步到从节点需要时间，可能造成主从节点的数据不一致。主写从读无非就是为了减轻leader节点的压力，将读请求的负载均衡到follower节点，如果Kafka的分区相对均匀地分散到各个broker上，同样可以达到负载均衡的效果，没必要刻意实现主写从读增加代码实现的复杂程度。
#### producer
生产者，就是向 topic 生产消息的应用程序。
#### consumer
消费者，就是从 topic 消费消息的应用程序。
#### consumer offset
消费偏移量：表征消费者消费进度，每个消费者都有自己的消费者位移。
#### consumer group
消费者组：多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。
#### rebalance
重平衡，kafka 中一个大名鼎鼎的消息重分配机制。假设一个消费组内的 consumer A 宕机了，kafka 能够自动检测到，并且把 consumer A 原先负责的 partition 重新分配给其他活着的 consumer。

### kafka 持久化数据原理
AOF（Append-only-file），不错就是 redis 数据持久化方式之一，只不过 redis 是追加编辑数据的命令，而 kafka 是追加消息数据到日志（Log）来保存数据。一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。
#### 保证日志在磁盘的可持续存储
kafka 为了保存日志数据能够可持续在磁盘上存储提供了两种策略：日志分段机制（Log Segment）、周期性检查过期删除

- 日志分段机制：在 Kafka 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。
- 周期性检查过期删除：Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。

### kafka 三层架构
- 主题层：每个主题可以设置一个或多个分区，每个分区又可以设置一个或多个副本
- 分区层：每个分区的副本中有且只有一个是领导副本并对外提供读写功能，其余的都是追随副本只能同步领导副本的数据
- 消息层：分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。

### kafka 不只是消息引擎系统
kafka 还是一个分布式流处理平台（Distributed Streaming Platform），Kafka 社区于 0.10.0.0 版本正式推出了流处理组件 Kafka Streams。
#### Kafka Streams 优势
- kafka 更容易实现端到端的正确性，正确性一直是批处理的强项，而实现正确性的基石则是要求框架能提供精确一次处理语义，即处理一条消息有且只有一次机会能够影响系统状态。
- kafka 对于流式计算的定位，官网上明确标识 Kafka Streams 是一个用于搭建实时流处理的客户端库而非是一个完整的功能系统。

##### 精确一次处理语义（exactly once）
举个例子，如果我们使用Kafka计算某网页的PV——我们将每次网页访问都作为一个消息发送的Kafka。PV的计算就是我们统计Kafka总共接收了多少条这样的消息即可。精确一次处理语义表示每次网页访问都会产生且只会产生一条消息，否则有可能产生多条消息或压根不产生消息。



